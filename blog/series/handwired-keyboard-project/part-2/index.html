<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The Linux Kernel, Device layers, i2c drivers, and kernel module">

    <title>Handwired Keyboard Project: Part 2</title>

    <meta name="application-name" content="Simon Willshire"/>
    <meta name="msapplication-TileColor" content="#FFFFFF" />
    <meta name="msapplication-TileImage" content="/icons/mstile-144x144.png" />
    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="../../../../icons/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../../../icons/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../../icons/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../icons/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../../../../icons/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../../icons/apple-touch-icon-152x152.png" />
    <link rel="icon" type="image/png" href="../../../../icons/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="../../../../icons/favicon-16x16.png" sizes="16x16" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" type="text/css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway" type="text/css">
    <link rel="stylesheet" href="../../../../css/styles.css" type="text/css">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/default.min.css" type="text/css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css" type="text/css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>

    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-74342154-1', 'auto');
      ga('send', 'pageview');
    </script>
  </head>

  <body>
    <div class="panel">
      <div class="panel-header">
        <a class="brand" href="../../../../">
          Simon Willshire
        </a>

       <div class="social">
  <a href="https://github.com/Tiggilyboo"><span class="fa fa-github" alt="GitHub"></span></a>
  <a href="http://bitbucket.com/Tiggilyboo"><span class="fa fa-bitbucket" alt="Bitbucket"></span></a>
  <a href="http://stackoverflow.com/users/3969264/tiggilyboo"><span class="fa fa-stack-overflow"></span></a>
  <a href="https://soundcloud.com/tiggilyboo"><span class="fa fa-soundcloud"></span></a>
</div>


        <div class="panel-list container">
          <a href="../../../../">Home</a>
          <a href="../../../../blog">Blog</a>
          <a href="https://siveetravels.com">Travel</a>
          <a href="../../../../music">Music</a>
          <a href="../../../../contact">Contact</a>
          <a href="../../../../about">About</a>
      </div>
    </div>
  </div>

  <div class="container">

  

  <main id="single" role="main">
    <div class="article-header">
      <h1>Handwired Keyboard Project: Part 2</h1>
      <div class="meta">
        <span class="date">
          <i class="fa fa-clock"></i>
          Sep 13, 2019
        </span>
        &nbsp;
        <div class="tags">
        
          <a href="../../../../tags/linux">Linux</a>&nbsp;
        
          <a href="../../../../tags/kernel">Kernel</a>&nbsp;
        
          <a href="../../../../tags/c">C</a>&nbsp;
        
          <a href="../../../../tags/planck">Planck</a>&nbsp;
        
          <a href="../../../../tags/keyboards">Keyboards</a>&nbsp;
        
          <a href="../../../../tags/arm">ARM</a>&nbsp;
        
        </div>
      </div>
    </div>
    <div class="tags" style="text-align: center">
      
        This article is part of the series 
        
          <a href="../../../../series/handwired-keyboard-project">Handwired Keyboard Project</a></li>
         
       
    </div>

    <article>
            <h2 id="intro">Intro</h2>
<p>As a quick refresher from the first part in the series, I&rsquo;m making a handwired keyboard which uses an altogether rediculous chinese knockoff 6 core monster SBC (The RK3399). Better yet, there are not enough GPIOs available on the board to handle the input matrix (12x4). Oh, and the case I want to use (from my current keyboard does not have enough vertical headroom to fit it, so I have to manually strip the taller components by hand so it has enough clearance.</p>
<p>Along my journey, I&rsquo;ve fried an entire board (So far only once) by accidentally shorting some of the 40-pin header to test my kernel module - By and large, making mistakes with the nonchalance of a primarily web based software developer&hellip; So, the second board has arrived and I&rsquo;ve made enough progress to write another article.</p>
<h2 id="the-linux-kernel">The Linux Kernel</h2>
<p>I&rsquo;ve come into this project with a little knowledge of kernel module compilation, but have never had to write anything quite as drastic at this - let&rsquo;s just say it has taken much longer than expected, but lot&rsquo;s has been learned&hellip;</p>
<p>As per my strict self-imposed requirements, I want some fast interrupt based kernel level hardware interaction, I could have done this in python and flailed a stray cpu in a loop polling the device, but that&rsquo;s just poor form. In order to achieve this, several pieces need to come together:</p>
<p>A kernel module containing</p>
<ol>
<li>Device driver to access <strong>gpio</strong> and interrupts when a state has changed (button presses)</li>
<li>Device driver to access <strong>i2c</strong> so that enough interruptible inputs can coexist (Current PCB does not support 16 GPIOs simultaneously).</li>
<li>Device driver to access <strong>USB HID</strong> (that is Human Interface Device) that represents a keyboard so that I can plug in the keyboard to external USB ports providing power and peripheral to make input device.</li>
<li>Device driver to access internal <strong>input</strong> events (Simple input device) for when I dont want the keyboard to act as a preipheral.</li>
</ol>
<h3 id="device-tree-overlays">Device Tree Overlays</h3>
<p>Much to my frustration while writing the kernel driver, I could not for the life of me get the i2c device to probe. After some research, I discovered that you need to write an overlay in order to communicate with the hardware that you require for the device. As I&rsquo;ve never written or even seen these before, it was a little daunting&hellip; Luckily, someone had written support for the MCP23017 for the raspberry pi, so I was able to adapt it based on the NanoPi&rsquo;s addresses by decompiling the Nanopi&rsquo;s dtbo and checking the aliases exposed to the system).</p>
<pre tabindex="0"><code>/dts-v1/;

/ {
  compatible = &#34;rockchip,rk3399&#34;;
  
  fragment@0 {
    target-path = &#34;/i2c@ff120000&#34;;

    __overlay__ {
      status = &#34;okay&#34;; 
    };
  };

  fragment@1 {
    target-path = &#34;/pinctrl/gpio0@ff720000&#34;;

    __overlay__ {
      planck_pins: planck_pins {
        rockchip,pins = &lt;32&gt;;
        rockchip,function = &lt;0&gt;;
      };
    };
  };

  fragment@2 {
    target-path = &#34;/i2c@ff120000&#34;;

    __overlay__ {
      #address-cells = &lt;1&gt;;
      #size-cells = &lt;0&gt;;

      planck: planck@27 {
        compatible = &#34;planck&#34;;
        reg = &lt;0x27&gt;;
        gpio-controller;
        #gpio-cells = &lt;2&gt;;
        #interrupt-cells = &lt;2&gt;;
        interrupt-parent-path = &#34;/pinctrl/gpio0@ff720000&#34;;
        interrupts = &lt;32 2&gt;;
        interrupt-controller;
        microchip,irq-mirror;

        status = &#34;okay&#34;;
      };
    };
  };
};
</code></pre><p>In order to find those hex addresses, I had to decompile the overlay from <a href="https://www.armbian.com">Armbian</a> for my board using:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>$ dtc -I dtb -O dts -o device-tree.dts /boot/dtb/rockchip/rk3399-nanopi4-rev01.dtb
</span></span></code></pre></div><p>Have a glance through device-tree.dts for the i2c interface / device you want to bind your overlay too.
In my case, we needed to bind:</p>
<ul>
<li>i2c interface for the MCP23017 port expander</li>
<li>A gpio pin for interrupts from the i2c device</li>
</ul>
<p><strong>Note</strong>: the <code>compatible = &quot;planck&quot;</code> name should line up with the device name you are setting up in your kernel module.</p>
<h2 id="the-kernel-module">The Kernel Module</h2>
<p>There are several logical parts to the driver, before we get started on the code, lets take a second to figure out what the flow will be, from button press to registering a key press.</p>
<p><img src="http://simonwillshire.com/public/images/planck-flow.svg" alt="linux kernel flow"></p>
<p>So, a button grounds two inputs (one for the X axis, the other for the Y). This fires an interrupt to gpio32, which triggers a full read of the interrupt register (MCP23017_INTCONA and B) via i2c. Once read, we need to check the difference between the last state and the new state. The difference raises an input event according to the X and Y mapping of a keycode. Hey presto, an internal keyboard driver.</p>
<h3 id="i2c-device">I2C Device</h3>
<p>The basics, we need write a series of register bytes in order to setup the MCP23017 in the way we want to use it. In my use case, I will be mirroring both banks (A and B), so that if any bank changes the interrupt is fired. The change is from high ie 1 to 0, which is called a falling edge interrupt.</p>
<p>In practice, this means:</p>
<ul>
<li>Set MCP23017_IODIRA and B = 0xff ie 1111 1111 (input direction for all)</li>
<li>Set MCP23017_GPPUA and B = 0xff so that we use the internal pull up/down resistors so we don&rsquo;t get flappy values</li>
<li>Set MCP23017_CONA and B = 0x62
<ul>
<li>0x40 = mirroring enabled accross bank A and B.</li>
<li>0x20 = disable sequential operations (Usually used for polling, the device increments the addrss automatically).</li>
<li>0x02 = high polarity (default state is high).</li>
</ul>
</li>
<li>Set MCP23017_INTENA and B = 0xff to enable interrupts on all inputs</li>
</ul>
<p>Once we&rsquo;ve set up the device configuration, in order to start using the device, you clear the interrupt state by reading the INTCAP or GPIO registers.</p>
<p>This looks something like this (trimmed down version) to setting up your i2c driver via i2c_driver.probe:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">planck_probe</span>(<span style="color:#66d9ef">struct</span> i2c_client <span style="color:#f92672">*</span>client, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> i2c_device_id <span style="color:#f92672">*</span>id) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> planck_device <span style="color:#f92672">*</span>device;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">i2c_check_functionality</span>(client<span style="color:#f92672">-&gt;</span>adapter, 
</span></span><span style="display:flex;"><span>        I2C_FUNC_SMBUS_BYTE_DATA <span style="color:#f92672">|</span> I2C_FUNC_SMBUS_WORD_DATA <span style="color:#f92672">|</span> I2C_FUNC_SMBUS_I2C_BLOCK)){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENODEV;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Setup all inputs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_IODIRA, <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_IODIRB, <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Setup pullups
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_GPPUA, <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_GPPUB, <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Setup interrupt mirrorring disable SEQOP, polarity HIGH 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_IOCONA, <span style="color:#ae81ff">0x62</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_IOCONB, <span style="color:#ae81ff">0x62</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Setup interrupt on change
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_GPINTENA, <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">i2c_write_byte</span>(client, MCP23017_GPINTENB, <span style="color:#ae81ff">0xff</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">goto</span> i2c_err;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">goto</span> i2c_ok;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>i2c_err:
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>i2c_ok:
</span></span><span style="display:flex;"><span>  device <span style="color:#f92672">=</span> <span style="color:#a6e22e">devm_kzalloc</span>(<span style="color:#f92672">&amp;</span>client<span style="color:#f92672">-&gt;</span>dev, <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> planck_device), GFP_KERNEL);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(device <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM; 
</span></span><span style="display:flex;"><span>  device<span style="color:#f92672">-&gt;</span>i2c <span style="color:#f92672">=</span> client;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Read the initial state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">i2c_set_clientdata</span>(client, device);
</span></span><span style="display:flex;"><span>  device<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> <span style="color:#a6e22e">planck_read_state</span>(device, MCP23017_INTCAPA);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="gpio">GPIO</h4>
<p>Great, now that we have an i2c device, we want to handle some interrupts, the MCP23017 has an interrupt wire when a change occurs, attach this to a GPIO pin and configure it thus:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">planck_configure_gpio</span>(<span style="color:#66d9ef">struct</span> planck_device <span style="color:#f92672">*</span>device)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#a6e22e">gpio_is_valid</span>(<span style="color:#ae81ff">32</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>res){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENODEV;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_request</span>(<span style="color:#ae81ff">32</span>, <span style="color:#e6db74">&#34;gpio_interrupt&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_direction_input</span>(<span style="color:#ae81ff">32</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">gpio_set_value</span>(<span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  device<span style="color:#f92672">-&gt;</span>irq_number <span style="color:#f92672">=</span> <span style="color:#a6e22e">gpio_to_irq</span>(GPIO_INTERRUPT);
</span></span><span style="display:flex;"><span>  res <span style="color:#f92672">=</span> <span style="color:#a6e22e">request_irq</span>(device<span style="color:#f92672">-&gt;</span>irq_number, (<span style="color:#66d9ef">irq_handler_t</span>)planck_gpio_interrupt, IRQF_TRIGGER_RISING, <span style="color:#e6db74">&#34;planck_interrupt&#34;</span>, device);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>Notice</strong> <code>IRQF_TRIGGER_RISING</code>, this is not to be confused with the state of the i2c inputs, the MCP23017 will raise the input from low to high. Whereas internally, the MCP23017 inputs are triggering the interrupt from 0 to 1 and 1 to 0 (both ways).</p>
<p>Call this configuration from within your probe event handler. Once complete, you need to set up our marvilous interrupt handler function (aka irq handler)!</p>
<p>We will be introducing a few concepts so that the device does not wait on itself or have race conditions namely through bottom half processing and spin locks. I found some great documentation from IBM <a href="https://developer.ibm.com/tutorials/l-tasklets/">here</a>.</p>
<h4 id="interrupts-and-bottom-half-processing">Interrupts, and Bottom half processing</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">irq_handler_t</span> <span style="color:#a6e22e">planck_gpio_interrupt</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev_id, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs)
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> planck_device <span style="color:#f92672">*</span>device <span style="color:#f92672">=</span> dev_id;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(device <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">irq_handler_t</span>)IRQ_HANDLED;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// spin lock so we don&#39;t clobber our state if another concurrent interrupt happens while queuing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">spin_lock_irqsave</span>(<span style="color:#f92672">&amp;</span>device<span style="color:#f92672">-&gt;</span>irq_lock, flags);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> planck_i2c_work<span style="color:#f92672">*</span> work <span style="color:#f92672">=</span> 
</span></span><span style="display:flex;"><span>    (<span style="color:#66d9ef">struct</span> planck_i2c_work<span style="color:#f92672">*</span>)<span style="color:#a6e22e">kmalloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> planck_i2c_work), GFP_KERNEL);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">INIT_WORK</span>((<span style="color:#66d9ef">struct</span> work_struct<span style="color:#f92672">*</span>)work, planck_work_handler);
</span></span><span style="display:flex;"><span>  work<span style="color:#f92672">-&gt;</span>device <span style="color:#f92672">=</span> device;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">queue_work</span>(device<span style="color:#f92672">-&gt;</span>read_wq, (<span style="color:#66d9ef">struct</span> work_struct<span style="color:#f92672">*</span>)work); ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">planck_queue_i2c_work</span>(device);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">spin_unlock_irqrestore</span>(<span style="color:#f92672">&amp;</span>device<span style="color:#f92672">-&gt;</span>irq_lock, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">irq_handler_t</span>)IRQ_HANDLED;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Bueno, this queues some work for later also whilst passing our device pointer. Finally, doing some actual work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">planck_work_handler</span>(<span style="color:#66d9ef">struct</span> work_struct <span style="color:#f92672">*</span>w)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> y;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint16_t</span> state;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint16_t</span> last_state;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> keycode;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> planck_i2c_work <span style="color:#f92672">*</span>work <span style="color:#f92672">=</span> <span style="color:#a6e22e">container_of</span>(w, <span style="color:#66d9ef">struct</span> planck_i2c_work, work);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> planck_device <span style="color:#f92672">*</span>dev <span style="color:#f92672">=</span> work<span style="color:#f92672">-&gt;</span>device;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(dev <span style="color:#f92672">==</span> NULL){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_ERR <span style="color:#e6db74">&#34;planck: work_struct has no device!&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> finish;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  last_state <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>state;
</span></span><span style="display:flex;"><span>  dev<span style="color:#f92672">-&gt;</span>state <span style="color:#f92672">=</span> <span style="color:#f92672">~</span><span style="color:#a6e22e">planck_read_state</span>(dev, MCP23017_INTCAPA);
</span></span><span style="display:flex;"><span>  state <span style="color:#f92672">=</span> dev<span style="color:#f92672">-&gt;</span>state;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// Nothing changed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span>(state <span style="color:#f92672">==</span> last_state <span style="color:#f92672">||</span> <span style="color:#f92672">~</span>last_state <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> finish;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(y <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; y<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> currY <span style="color:#f92672">=</span> (state <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> y));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> lastY <span style="color:#f92672">=</span> (last_state <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> y));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">12</span>; x<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> currX <span style="color:#f92672">=</span> (state <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (x <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>)));
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">int</span> lastX <span style="color:#f92672">=</span> (last_state <span style="color:#f92672">&amp;</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> (x <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>)));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// Currently pressed, was not pressed before (Pressed)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!!</span>currX <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!!</span>currY <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!</span>lastY <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>lastX)){
</span></span><span style="display:flex;"><span>        keycode <span style="color:#f92672">=</span> planck_keycodes[(y <span style="color:#f92672">*</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">+</span> x];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;planck: pressed (%d, %d), keymap = %d, state = %d, last = %d&#34;</span>, x, y, keycode, state, last_state);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">input_event</span>(dev<span style="color:#f92672">-&gt;</span>input, EV_KEY, keycode, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>      } 
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// No longer pressed, pressed before (Released)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>((<span style="color:#f92672">!</span>currX <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>currY) <span style="color:#f92672">&amp;&amp;</span> (<span style="color:#f92672">!!</span>lastY <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!!</span>lastX)){
</span></span><span style="display:flex;"><span>        keycode <span style="color:#f92672">=</span> planck_keycodes[(y <span style="color:#f92672">*</span> <span style="color:#ae81ff">12</span>) <span style="color:#f92672">+</span> x];
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;planck: released (%d, %d), keymap = %d, state = %d, last = %d&#34;</span>, x, y, keycode, state, last_state);
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">input_event</span>(dev<span style="color:#f92672">-&gt;</span>input, EV_KEY, keycode, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">input_sync</span>(dev<span style="color:#f92672">-&gt;</span>input);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// cleanup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>finish:
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;planck: cleaning up work_handler&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">kfree</span>((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)w);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The above is probably the most logic in the entire kernel module. Lets try to disect it a bit.</p>
<ul>
<li>The top section is pulling out or device driver from our work_struct so we can be a useful worker.</li>
<li>We keep track of the last processed state within <code>last_state</code>, put our new state into <code>dev-&gt;state</code> and negate it (we are operating with polarity high, so we want to check for 0s)</li>
<li>Loop through our input matrix (12 x 4), checking the bits in last and current state
<ul>
<li><strong>Format: XXXX XXXX XXXX YYYY</strong> within an unsigned short.</li>
</ul>
</li>
<li>If we&rsquo;ve pressed the state and the old state was not processed before, register a key press.</li>
<li>Otherwise, check to see if the last state was pressed and the current state is released.</li>
</ul>
<p>Wait, but there are calls to input_event in there, we have not set it up yet!</p>
<h4 id="internal-input-device">Internal Input Device</h4>
<p>So this would not be a keyboard driver without an input driver, otherwise we are just spamming the kernel log&hellip; We want to register a new input device, which outputs <code>EV_KEY</code> ie. keyboard events, and we want to map events to keycodes and output those keycodes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">planck_init_input</span>(<span style="color:#66d9ef">struct</span> planck_device<span style="color:#f92672">*</span> device)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> input_dev<span style="color:#f92672">*</span> input;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> ret;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> num_keycodes <span style="color:#f92672">=</span> <span style="color:#a6e22e">ARRAY_SIZE</span>(planck_keycodes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;planck: initialising input...&#34;</span>);
</span></span><span style="display:flex;"><span>  input <span style="color:#f92672">=</span> <span style="color:#a6e22e">input_allocate_device</span>();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(input <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENOMEM;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  input<span style="color:#f92672">-&gt;</span>evbit[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">BIT_MASK</span>(EV_KEY);
</span></span><span style="display:flex;"><span>  input<span style="color:#f92672">-&gt;</span>keycode <span style="color:#f92672">=</span> planck_keycodes;
</span></span><span style="display:flex;"><span>  input<span style="color:#f92672">-&gt;</span>keycodesize <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span>); 
</span></span><span style="display:flex;"><span>  input<span style="color:#f92672">-&gt;</span>keycodemax <span style="color:#f92672">=</span> num_keycodes;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; ret <span style="color:#f92672">&lt;</span> num_keycodes; ret<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(planck_keycodes[ret] <span style="color:#f92672">!=</span> KEY_RESERVED)
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">set_bit</span>(planck_keycodes[ret], input<span style="color:#f92672">-&gt;</span>keybit);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">input_register_device</span>(input);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_ERR <span style="color:#e6db74">&#34;planck: unable to register input device, register returned %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ret);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> input_err;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_DEBUG <span style="color:#e6db74">&#34;planck: initialised input device with %d keycodes&#34;</span>, num_keycodes);
</span></span><span style="display:flex;"><span>  device<span style="color:#f92672">-&gt;</span>input <span style="color:#f92672">=</span> input;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>input_err:
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">input_unregister_device</span>(input);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>ENODEV;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What&rsquo;s this <code>planck_keycodes</code> array? It&rsquo;s the keymapping which allows us to map our input matrix (12x4) to input keycodes.</p>
<p>The kernel module keymapping which I type on (Colemak with 3 layers, only one is below to keep the article short):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/input.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#75715e">/* ,-----------------------------------------------------------------------------------.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * | Tab  |   Q  |   W  |   F  |   P  |   G  |   J  |   L  |   U  |   Y  |   ;  | Bksp |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * |------+------+------+------+------+-------------+------+------+------+------+------|
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * | Esc  |   A  |   R  |   S  |   T  |   D  |   H  |   N  |   E  |   I  |   O  |  &#34;   |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * |------+------+------+------+------+------|------+------+------+------+------+------|
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * | Shift|   Z  |   X  |   C  |   V  |   B  |   K  |   M  |   ,  |   .  |   /  |Enter |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * |------+------+------+------+------+------+------+------+------+------+------+------|
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * | Ctrl | GUI  | Alt  |WrkSp |Lower |Space | Bksp |Raise | Left | Down |  Up  |Right |
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  * `-----------------------------------------------------------------------------------&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">short</span> planck_keycodes[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// BASE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  KEY_TAB, KEY_Q, KEY_W, KEY_F, KEY_P, KEY_G, KEY_G, KEY_J, KEY_L, KEY_U, KEY_Y, KEY_SEMICOLON, KEY_DELETE,
</span></span><span style="display:flex;"><span>  KEY_ESC, KEY_A, KEY_R, KEY_S, KEY_T, KEY_D, KEY_H, KEY_N, KEY_E, KEY_I, KEY_O, KEY_APOSTROPHE, 
</span></span><span style="display:flex;"><span>  KEY_LEFTSHIFT, KEY_Z, KEY_X, KEY_C, KEY_V, KEY_B, KEY_K, KEY_M, KEY_COMMA, KEY_DOT, KEY_SLASH, KEY_ENTER, 
</span></span><span style="display:flex;"><span>  KEY_LEFTCTRL, KEY_LEFTMETA, KEY_LEFTALT, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, KEY_SPACE, KEY_BACKSPACE, <span style="color:#ae81ff">0</span>, KEY_LEFT, KEY_DOWN, KEY_UP, KEY_RIGHT, 
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The kernel module header in order to give some more perspective from the snippets above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kernel.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/module.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/init.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/i2c.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/gpio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/input.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/interrupt.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/workqueue.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;planck_keycodes.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define DEVICE_NAME       &#34;planck&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_INTERRUPT    32
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define GPIO_DEBOUNCE     50
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_IODIRA   0x00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_GPINTENA 0x04
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_DEFVALA  0x06
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_INTCONA  0x08
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_IOCONA   0x0A
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_INTCAPA  0x10
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_GPIOA    0x12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_IODIRB   0x01
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_IPOLB    0x03
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_GPINTENB 0x05
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_DEFVALB  0x07
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_INTCONB  0x09
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_IOCONB   0x0B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_INTCAPB  0x11
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define MCP23017_GPIOB    0x13
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_LICENSE</span>(<span style="color:#e6db74">&#34;GPL&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_AUTHOR</span>(<span style="color:#e6db74">&#34;Simon Willshire&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_DESCRIPTION</span>(<span style="color:#e6db74">&#34;Planck i2c keyboard driver for mcp23017&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_VERSION</span>(<span style="color:#e6db74">&#34;0.1&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> planck_device {                <span style="color:#75715e">// Our keyboard device, we lug this pointer around alot!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> workqueue_struct<span style="color:#f92672">*</span> read_wq;   <span style="color:#75715e">// We use a queue to do bottom half processing outside of the interrupt context 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> i2c_client <span style="color:#f92672">*</span>i2c;             <span style="color:#75715e">// The i2c driver client to interface with MCP23017
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">spinlock_t</span> irq_lock;                <span style="color:#75715e">// Interrupt locking mechanism so the driver does not crap itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq_number;            <span style="color:#75715e">// The interrupt number we have created to free up later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">uint16_t</span> state;                     <span style="color:#75715e">// The last i2c state we processed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> input_dev <span style="color:#f92672">*</span>input;            <span style="color:#75715e">// The input device to register internal inputs on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> planck_i2c_work {              <span style="color:#75715e">// When we need to process some work, we need to pass around our device pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> work_struct work;            
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">struct</span> planck_device <span style="color:#f92672">*</span>device;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Set up our device interface to bind our device tree overlay to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> of_device_id planck_ids[] <span style="color:#f92672">=</span> {{.compatible <span style="color:#f92672">=</span> DEVICE_NAME},{}};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> i2c_device_id planck_id[] <span style="color:#f92672">=</span> { {DEVICE_NAME, <span style="color:#ae81ff">0</span>}, {}};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Declare our interrupt function and work handler for later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">irq_handler_t</span> <span style="color:#a6e22e">planck_gpio_interrupt</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> irq, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>dev_id, <span style="color:#66d9ef">struct</span> pt_regs <span style="color:#f92672">*</span>regs);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">planck_work_handler</span>(<span style="color:#66d9ef">struct</span> work_struct <span style="color:#f92672">*</span>w);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Ensure our device table is set up to probe
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">MODULE_DEVICE_TABLE</span>(i2c, planck_id);
</span></span></code></pre></div><h3 id="outro">Outro</h3>
<p>In the next article, I will be assembling the input matrix, implementing multiple keyboard keycode layers (upper, lower).
After that, we need to define a switch to toggle between internal input handling and external USB HID handling.</p>
<p>The latest full version of the full source can be found at my github <a href="https://github.com/tiggilyboo/planck">here</a></p>


      
    </article>

    
      <div id="disqus_thread"></div>

<script type="text/javascript">
(function(){
  if(window.location.hostname == "localhost") return;

  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  var disqus_shortname = 'simonwillshire';
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0]).appendChild(dsq);

  var dsqc = document.createElement('script'); dsqc.id = 'dsq-count-scr'; dsqc.type = 'text/javascript'; dsqc.async = true;
  dsqc.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0]).appendChild(dsqc);
})();
</script>
<noscript>Please enable JavaScript to view comments.</noscript>

    

    <nav class="pagination-single">
      
        <span class="previous">&larr; <a href="http://simonwillshire.com/blog/series/handwired-keyboard-project/part-3/" rel="prev">Handwired Keyboard Project: Part 3</a></span>
      
      
        <span class="next"><a href="http://simonwillshire.com/blog/series/handwired-keyboard-project/part-1/" rel="next">Handwired Keyboard Project: Part 1</a> &rarr;</span>
      
    </nav>
  </main>

    </div> 

    <footer class="footer">
      <div class="container">

        <div class="social">
  <a href="https://github.com/Tiggilyboo"><span class="fa fa-github" alt="GitHub"></span></a>
  <a href="http://bitbucket.com/Tiggilyboo"><span class="fa fa-bitbucket" alt="Bitbucket"></span></a>
  <a href="http://stackoverflow.com/users/3969264/tiggilyboo"><span class="fa fa-stack-overflow"></span></a>
  <a href="https://soundcloud.com/tiggilyboo"><span class="fa fa-soundcloud"></span></a>
</div>


      </div>
    </footer>
  </body>
</html>

